# mybatis优缺点

>优点：
>
>* 简单易学，基于sql编程
>* JDBC相比，消除了JDBC大量冗余的代码，不需要手动开关连接。
>* 很好地与数据库兼容，使用JDBC连接数据库，所以只要jdbc支持的，都可以直接使用，并且有可扩展性，引入jar包即可，开发人员不需要考虑数据库的差异性。
>* 提供了很多第三方插件，分页插件，逆向工程。
>* 能够与spring很好地集成。
>* SQL写在xml里，从程序中分离，解耦操作，并且可以服用。
>* 提供XML标签，支持编写动态sql语句（for each, if ）
>* 提供映射标签，支持对象与数据库的ORM字段关系映射



> 缺点：
>
> * sql语句编写工作量大，字段多，关联表多
> * sql语句过于依赖数据库，导致数据库移植性差，不能随意更换数据库。





# mybatis与hibernate区别

> 相同点：
>
> 都是通过sessionFactoryBuilder由XML配置文件生成sessionFactory，然后由sessionFactory生成session，最后由session 来开启执行事务和sql语句。
>
> 都支持JDBC和JTA事务处理。



> 不同点：
>
> * Hibernate是全自动，mybatis是半自动，Hibernate完全可以通过对象关系模型实现对数据库的操作，而mybatis仅有基本的字段映射，对象数据以及对象关系仍然需要通过手写sql来实现和管理。
> * Hibernate数据库移植性远大于mybatis，可以将Hibernate看做一个黑盒，通过强大的hql语言和映射关系，大大降低了与数据库的耦合性，而mybatis需要手写sql，耦合性直接取决于程序sql语句。
> * Hibernate具有完整的日志系统，mybatis缺点意思。
> * mybatis相比Hibernate需要关心很多细节，Hibernate配置要比前者复杂多，学习成本高，所以mybatis很容易上手开发，但会导致前期bug较多，后期需要debug注意细节。
> * sql优化上，mybatis要比Hibernate方便很多，因为Hibernate的hql很多都是自动生成的，遇到一些别的需求时，有局限性。
> * 缓存机制上，hibernate要比mybatis好一些。因为hibernate对查询对象有着良好的管理机制，用户无需关心sql，如果出现脏数据，系统汇报出错误并提示。



* ***脏读***：**事务A读取到了事务B已经修改但尚未提交的数据。**
* ***不可重读*** ：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”， **事务A内部的相同查询语句在不同时刻读出的结果不一致。**
* ***幻读*** ：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。**事务A读取到了事务B提交的新增数据**。幻读跟不可重复读有点像，**不可重复读是读到数据不一样，幻读是读的数据多**了。





## mybatis 中#{} 和 ${} 区别

* #{} 是预编译处理，而后者则是字符串替换
* mybatis在处理#{}时，会将sql中的#{} 替换为？号，调用prepareStatement的set方法来赋值
* mybatis在处理${}时，就是把${}替换成变量的值
* 使用#{} 可以有效的防止sql注入，提高系统安全性





## mysql的隔离级别有哪些

有四种隔离级别，用于限定事务内外哪些改变是可见的，哪些改变是不可见的，低级别的隔离一般支持更高的并发处理，并且拥有更低的系统开销。越往下隔离级别越高



> read uncommitted 读取未提交内容：
>
> 在这个隔离级别，所有事务都可以看到未提交事务的执行结果，在这种级别上，可能会产生很多问题，很少用于实际应用，也被成为脏读。



> read committed 读取提交内容
>
> 大多数数据库数据库默认隔离级别，但并不是mysql默认隔离级别，一个事务开始时，只能看见已经提交事务所做的改变，一个事物从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交，支持所谓的“不可重复读”。意味着运行一个语句两次，看到的结果不同的。



> repeatable read 可重复读
>
> MySQL数据库默认隔离级别，解决了第一个隔离级别的问题，保证同一事务的多个实例在并发读取事务时，会看到同样的数据行，不过会导致另外一个问题-幻读。InnoDB和falcon存储引擎通过多版本并发控制机制解决了幻读。



> serializable 可串行化
>
> 是最高级别的隔离级。通过强制事务排序，是相互之间不能冲突，就是在每个读的数据行上枷锁。可能会导致大量的timeout和锁竞争，实际应用中很少使用到。





## MySQL复制原理：

* master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中。
* slave服务器会在一定时间间隔内对master二进制日志进行探测是否发生改变，如果发生改变，则开始一个I/O thread请求master二进制事件
* 同时主节点为每个i/o线程启动一个dump线程，用于向其发送二进制时间，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放使得数据和主节点的保持一致，最后I/Othread和sqlthread将进入睡眠状态，等待下一次被唤醒。



## 聚簇索引

**聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页**





# MySQL聚簇和非聚簇索引的区别

***索引存在磁盘，因为如果断电后，重新生成索引非常耗时***

> mysql的索引类型跟存储引擎是相关的，innodb存储引擎数据文件跟索引文件全部都放在idb文件中，而myisam的数据文件放在myd文件中，所以放在myi中，所以区分两种索引，只要判断**数据跟索引是否存储在一起**



> innoodb存储引擎在进行数据插入的时候，数据必须要根索引放在一起，如果有主键就是用主键，没有主键就是用唯一键，再没有就是用6字节的rowid，因此数据绑定在一起的就是聚簇索引，而为了避免数据冗余存储，其他的索引的叶子节点中存储的都是聚簇索引的key值，因此在innodb中既有聚簇也有非聚簇，而myisam中只有非聚簇。



# Mysql 索引结构有哪些，各自的优势

