# HashMap和HashTable的区别

* HashTable是线程同步，hashMap非线程同步（及安全性）
* hashTable不允许键值对有空值，hashMap允许键值对有空值
* hashTable使用Enumeration， HashMap使用iterator。
* hashTable中hash数组的默认大小是11，增加方式的old*2 + 1，hashMap数组默认是16，增加是2的指数倍
* 父类不同，HashTable继承Dictionary类，hashMap继承自abstractMap类，但是都实现了Map接口。





# HashMap有哪些线程安全的方式

首先明确hashMap并不是线程安全的，jdk原生提供了两种方法

* 通过Collections.sychronizedMap()返回一个新的map，这个新的map是线程安全的。
* 重新改写HashMap，可以看concurrentHashMap



方法1的特点：

> 通过collections封装所有不安全的hashmap方法，连toString和hashCode都进行了封装，使用了synchronized来进行互斥，使用了代理模式new了一个新的类，这个类同样实现了map接口，先来先优先原则来得到锁。 优点是实现十分简单，缺点就是锁住了尽可能大的代码块，性能会比较差。

方法2的特点：

> 重新了hashMap，使用了新的锁机制，把hashMap进行了拆分，拆分成多个独立的快，在高并发的情况下，减少了锁冲突的可能，使用的是NonfairSync，调用CAS指令来确保原子性和互斥性。
>
> 优点是需要互斥的代码块较少，性能比较好，缺点是代码繁琐。



# HashMap在扩容上有哪些优化

在jdk1.7版本的时候，扩容计算每次都是对元素进行rehash算法，计算原来每个元素在扩容之后的哈希表中的位置，而在jdk1.8之后借助2倍扩容机制，元素不需要进行重新计算为止



hashmap使用的是2次幂的扩展，所以位置要么是在原位置，要么是在原位置在移动2次幂的位置。（二进制与运算，看最高位bit）为了减少Hash碰撞，尽量使Hash算法的结果均匀分布





# MVCC解决的问题是什么

数据库并发场景有三种：

* 读读，不存在任何问题，不需要并发控制。
* 读写，有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读。
* 写写，有线程按期按问题，可能存在更新丢失问题。

> MVCC 是一种用来解决读写冲突的无锁并发控制，也就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联。读操作只读事务开始前的数据库快照，所以MVCC可以为数据库解决以下问题
>
> * 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
> * 解决了脏读，幻读不可重复读等事务隔离问题，但是不能解决更新丢失问题。