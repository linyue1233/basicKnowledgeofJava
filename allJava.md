# JDK JRE JVM区别和联系

Jdk: java development kit,开发工具

Jre: java runtime environment

jvm: 虚拟机

jdk( JRE(bin,jvm,lib), Java工具)



.java 文件通过javac编译城.class文件，最后通过jvm映射到系统调用。



# == 和equals区别

一个是运算符一个是方法， equals不能用于基本数据类型

== 如果比较的对象是基本数据类型，比较数值是否相等，如果是引用数据类型，则是堆中的对象的地址值是否相等

equals 用来比较两个对象的内容是否相等。





# 堆栈区别

线程独享：栈，程序计数器

线程共享： 堆， 方法区

栈：又称方法栈，用来存储局部变量，操作栈，方法出口等。

堆：JVM内存管理中最大的一块，存放的是对象的实例，如果堆中没有空间，就会爆出OOM，根据对象的存活周期不同，jvm的把对象进行分代管理，由垃圾回收器回收。





#  Java的接口和抽象类有哪些去区别

**相同**：

> 不能实例化， 可以将抽象类和接口类型作为引用类型
>
> 一个类如果继承了某个抽象类或者实现某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明抽象类。

**区别**：

> ​		抽象类：
>
> *  ***抽象类中可以定义构造器***
> *  ***可以有抽象方法和具体方法***
> *  抽象类中的成员可以是privat，protected或者public
> *  抽象类中可以定义成员变量
> *  ***有抽象方法的类必须被声明为抽象类，有抽象类的未必要有抽象方法***
> *  ***抽象类中可以包含静态方法***
> *  ***一个类只能继承一个抽象类***



> 接口：
>
> * 接口中不能定义构造器
> * 方法全部都是抽象方法
> * 接口中的成员全部都是public
> * 接口中不能有静态方法
> * 一个类可以实现多个接口



抽象类重点是描述的一个抽象概念，比如说一个动物，哺乳动物。

接口描述某些事物具有的共同特征，比如说飞，鸟和飞机。

中高级回答：

接口的设计目的是对类的行为进行约束

抽象类主要是代码复用。 



# Java面向对象特征

* 继承：从已有的类中派生出新的类，新的类吸收已有类的数据属性和方法，并继承新的能力。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性和方法。通过extends关键字来实现继承，父类中通过private定义的变量和方法不会被继承，但是可以操作。
* 封装：隐藏了类的内部实现机制，同时保护了数据，对外界它的内部细节是隐藏的，不必关心方法的内部实现，
* 多态：指的是类和类之间的关系（重载，重写），必备的三个要素，继承，重写，父类引用指向子类对象。基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。可移植性，健壮性。



# fina 作用，为什么局部内部类和匿名内部类只能访问局部final变量

修饰类：类不可以被继承

方法：表示不可被子类覆盖，但是可以重载

修饰变量：一旦被赋值就不能更改。



final修饰的类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值

修饰成员变量：可以在非静态初始化块，声明改该变量或者构造器中执行赋值。



修饰局部变量：

系统不会为局部变量进行初始化，局部变量必须有程序员显示初始化。因此使用final修饰局部变量是，即可以在定义时指定默认值，后面就不能对变量再赋值。或者不指定默认值，后续代码块变量赋值（用一次）。



修饰基本类型数据：则其数值一旦在初始化之后不能再次更改

修饰引用类型数据，声明之后不能再指向别的对象，但是引用的值是可以变的。



为什么内部类只能访问局部final，因为会生成两个,class文件，内部类不会随着外部类执行完成就会被销毁（比如说线程），所以外部类方法结束后，局部变量会被销毁，但是内部类有可能还会使用者局部变量。为了解决这个问题，jvm复制了一份作为内部类的成员变量。但是要保证两个变量是一样的，所以就将该局部变量设置为final。





## 重载重写的区别

* 重写：实现的是运行是的多态性，重写发生在子类与父类中，重写方法要求子类与父类有相同的返回类型。参数列表必须与被重写方法一直，构造方法不能被重写，final，static声明的方法都不能被重写，不能抛出新的强制性异常。访问权限不能比父类中被重写的方法的访问权限更低，private父类则子类不能重写该方法。
* 重载：实现的编译时的多态性，发生在一个类中，同名的方法如果有不同的参数列表则视为重载，没有返回类型的特殊要求。可以存在于父类和子类中，可以抛出不同的异常，可以有不同修饰符。

 

# StringBuilder， StringBuffer

* String: 引用的字符串内容不能被改变，每次操作都会生成一个新的string对象。
* StringBuffer: 字符串类型可以直接修改，jdk1.0，线程安全。
* StringBuilder: 字符串类型可以直接修改，jdk1.5与sb的区别他是在单线程环境下使用的，所有的方法都没有被synchronized，底层是数组，value表示数组的值，count表示被占用的长度，会做扩容，因此效率理论上更高。





# List 和set

> List集合，包含ArrayList和linkedlist，ArrayList是数组是动态底层连续内存存储，适合随机访问，扩容机制，将老数据拷贝到新数组，使用尾插发并制定初始容量可以极大提升性能。
>
> 另一个则是链表，分散在内存中，适合插入和删除操作，不适合查询，使用iterator遍历，因为使用for循环通过get方法取得元素时需要对list重新遍历。
>
> ArrayList遍历速度快，查询快，链表增删操作快，但是在正常业务中，遍历的需求多，增加元素一般都是直接放在尾部，时间复杂度也为O（1）。



> Set集合，包含HashSet，TreeSet，LinkedHashSet，set集合用来保证数据的唯一性，其中Treeset可以排序

list 有序，按照对象进入的顺序保存对象，可以重复，可以有多个null值，可以随机access或者iterator取出所有元素。



# hashmap和hashtable区别

使用红黑树可以加快查询速度，因为在jdk1.8之后，在链表的长度大于8后，hashmap将后面的数据存在红黑树中，（数组+链表->数组+树），时间复杂度从n到logn

内部实现是一个桶数组，每一个桶中存放一个单链表的头结点，每个结点存储的是一个键值对Entry，采用拉链法解决哈希冲突

扩容：hashmap(int initialCapacity, float factor)，第一个参数是初始容量，第二个装载因子，默认0.75，put操作时，先计算出hash值，找到对一个的桶位置，然后遍历这个桶上的链表，若没有找到与键相对的entry，新建一个。如果size已经大于阈值（factor * capacity），则扩容。

所以扩容条件是：**当`map`中包含的`Entry`的数量大于等于`threshold = loadFactor * capacity`的时候，且新建的`Entry`刚好落在一个非空的桶上，此刻触发扩容机制，将其容量扩大为2倍**。**旧桶数组中的某个桶的外挂单链表是通过头插法插入新桶数组中的，并且原链表中的Entry结点并不一定仍然在新桶数组的同一链表**。

在多线程的情况下，很容易出现无限进行链表反转的操作，容易死循环，所以采用concurrentHashmap。

hashmap允许key和value为null，jdk1.8中是插入尾部，之前都是插入头部，并且从entry变成了node



# hashcode 和 equals

* hashcode():   用于获取给定对象的唯一的整数（散列码），当这个对象需要存储在哈希表时，这个整数即可用来确定桶的位置。默认情况下，返回对象所在内存地址的整数表示。hash散列算法，使得hash表中查找一个记录速度为O1。在查找一个元素时，先通过hashcode快速定位记录的位置，然后通过equals来比较是否相等。
* equals():  不重新写，默认采用object 的equals（就是双等号），所以string是重写的。

hashcode的作用，如果两个对象的hashcode不同就可以不用比较值了，如果相同，在执行equals方法。





# 单点登录原理和实现sso

之前的做法是，登录之后，用户的session中标记登录状态为yes，同时在浏览器中写入cookie，这个cookie是这个用户的唯一标识。下次访问这个应用时，请求中会带上这个cookie，服务端会根据这个cookie找到对应的session，然后通过session判断这个用户是否登录。

但是cookie不能跨域，所以对多个业务系统无法无法操作，不同应用的session是存在自己的应用中，无法共享。

所以使用sso系统（在具有多个子系统的系统中，只需要登录一个子系统，其他系统则可以使用登录信息），流程如下：

1.用户首次访问A系统，A系统发现用户登录，重定向到soo认证中心并携带请求url，进行登录验证

2.用户在sso认证成功后，服务器生成一个ticket，然后重定向到A系统并带上这个ticket信息(放到url参数中)

3.系统A获取到url参数中的ticket，想sso发起ticket校验，校验成功，则A方形，并将ticket存入到cookie

4.用户访问B系统，此时B系统domain已经携带ticket，直接向sso放弃校验，校验成功则继续，并将ticket存入cookie，更新过期时间

5.用户登出时，移除domain下的cookie。





# String为什么不可变

因为string的对象缓存在string池中，由于缓存的字符串存在共享情况下，如果改变了一个就会导致别的地方出现问题





# JVM 如何处理异常

在Java中一个方法出现了异常，那么这个方法就会生成一个异常对象，该对象包含异常名称，异常描述和异常发生时应用程序的状态，然后将这个异常对象交给JVM。JVM顺着调用栈去处理，如果找到处理异常的代码，就交给这个代码去处理，把异常传递给这块代码，如果没有找到，jvm会交给异常的默认处理器。





# 字符流和字节流的区别

字节流-》字符流，通过inputsreamread 和outputStreamWrite

  1.处理单元不同

2. 字节流可以处理所有类型文件的数据传输，因为计算机的信息的最小单位就是字节，而字符流只能处理纯文本数据，其他不行，所以处理文本类型是用字符流多
3. 在读写文件需要对内容进行比对时，比如比较特定字符，处理某一行数据的时候一般选择字符流。
4. 只是读写文件，对文件内容无关时一般选用字节流。





# 阻塞IO与非阻塞IO区别

IO 操作包括对硬盘的读取， socket的读写以及外设的读写。

当用户发起一个io操作时，内核会去查看，如果数据没有准备好，就陷入等待状态，直到数据就绪。这就是阻塞。

非阻塞IO就是碰到如果这种情况，则会返回一个标志告知用户当前数据没有就绪，当数据就绪后，再将数据拷贝到用户线程，这才完成了一个IO操作。









# BIO NIO AIO

