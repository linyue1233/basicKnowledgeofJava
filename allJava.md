# JDK JRE JVM区别和联系

Jdk: java development kit,开发工具

Jre: java runtime environment

jvm: 虚拟机

jdk( JRE(bin,jvm,lib), Java工具)



.java 文件通过javac编译城.class文件，最后通过jvm映射到系统调用。



# == 和equals区别

一个是运算符一个是方法， equals不能用于基本数据类型

== 如果比较的对象是基本数据类型，比较数值是否相等，如果是引用数据类型，则是堆中的对象的地址值是否相等

equals 用来比较两个对象的内容是否相等。





# 堆栈区别

线程独享：栈，程序计数器

线程共享： 堆， 方法区

栈：又称方法栈，用来存储局部变量，操作栈，方法出口等。

堆：JVM内存管理中最大的一块，存放的是对象的实例，如果堆中没有空间，就会爆出OOM，根据对象的存活周期不同，jvm的把对象进行分代管理，由垃圾回收器回收。





#  Java的接口和抽象类有哪些去区别

**相同**：

> 不能实例化， 可以将抽象类和接口类型作为引用类型
>
> 一个类如果继承了某个抽象类或者实现某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明抽象类。

**区别**：

> ​		抽象类：
>
> *  ***抽象类中可以定义构造器***
> *  ***可以有抽象方法和具体方法***
> *  抽象类中的成员可以是privat，protected或者public
> *  抽象类中可以定义成员变量
> *  ***有抽象方法的类必须被声明为抽象类，有抽象类的未必要有抽象方法***
> *  ***抽象类中可以包含静态方法***
> *  ***一个类只能继承一个抽象类***



> 接口：
>
> * 接口中不能定义构造器
> * 方法全部都是抽象方法
> * 接口中的成员全部都是public
> * 接口中不能有静态方法，1.8之后可以有静态方法和默认方法，但是接口的静态方法不能被继承。
> * 一个类可以实现多个接口



抽象类重点是描述的一个抽象概念，比如说一个动物，哺乳动物。

接口描述某些事物具有的共同特征，比如说飞，鸟和飞机。

中高级回答：

接口的设计目的是对类的行为进行约束

抽象类主要是代码复用。 

## 默认方法：被public default修饰的默认方法

- 接口中public修饰符可以省略，default修饰符必须写
- 接口的实现类中可以重写default方法，重写时default修饰符必须不能加
- 接口的默认方法只能通过接口实现类或实现类的实例对象进行调用，调用方式见下面的代码：

## 为什么接口中要增加默认方法和静态方法

如果接口中只能定义抽象方法，当修改接口时，该接口的所有实现类都会受到影响，为了减小这种影响，所以才采用了这种方式



# Java面向对象特征

* 继承：从已有的类中派生出新的类，新的类吸收已有类的数据属性和方法，并继承新的能力。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性和方法。通过extends关键字来实现继承，父类中通过private定义的变量和方法不会被继承，但是可以操作。
* 封装：隐藏了类的内部实现机制，同时保护了数据，对外界它的内部细节是隐藏的，不必关心方法的内部实现，
* 多态：指的是类和类之间的关系（重载，重写），必备的三个要素，继承，重写，父类引用指向子类对象。基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。可移植性，健壮性。



# fina 作用，为什么局部内部类和匿名内部类只能访问局部final变量

修饰类：类不可以被继承

方法：表示不可被子类覆盖，但是可以重载

修饰变量：一旦被赋值就不能更改。



final修饰的类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值

修饰成员变量：可以在非静态初始化块，声明改该变量或者构造器中执行赋值。



修饰局部变量：

系统不会为局部变量进行初始化，局部变量必须有程序员显示初始化。因此使用final修饰局部变量是，即可以在定义时指定默认值，后面就不能对变量再赋值。或者不指定默认值，后续代码块变量赋值（用一次）。



修饰基本类型数据：则其数值一旦在初始化之后不能再次更改

修饰引用类型数据，声明之后不能再指向别的对象，但是引用的值是可以变的。



为什么内部类只能访问局部final，因为会生成两个,class文件，内部类不会随着外部类执行完成就会被销毁（比如说线程），所以外部类方法结束后，局部变量会被销毁，但是内部类有可能还会使用者局部变量。为了解决这个问题，jvm复制了一份作为内部类的成员变量。但是要保证两个变量是一样的，所以就将该局部变量设置为final。





## 重载重写的区别

* 重写：实现的是运行是的多态性，重写发生在子类与父类中，重写方法要求子类与父类有相同的返回类型。参数列表必须与被重写方法一直，构造方法不能被重写，final，static声明的方法都不能被重写，不能抛出新的强制性异常。访问权限不能比父类中被重写的方法的访问权限更低，private父类则子类不能重写该方法。
* 重载：实现的编译时的多态性，发生在一个类中，同名的方法如果有不同的参数列表则视为重载，没有返回类型的特殊要求。可以存在于父类和子类中，可以抛出不同的异常，可以有不同修饰符。

 

# StringBuilder， StringBuffer

* String: 引用的字符串内容不能被改变，每次操作都会生成一个新的string对象。
* StringBuffer: 字符串类型可以直接修改，jdk1.0，线程安全。
* StringBuilder: 字符串类型可以直接修改，jdk1.5与sb的区别他是在单线程环境下使用的，所有的方法都没有被synchronized，底层是数组，value表示数组的值，count表示被占用的长度，会做扩容，因此效率理论上更高。



![image-20220725004518953](/Users/linyue/Library/Application Support/typora-user-images/image-20220725004518953.png)

# List 和set

> List集合，包含ArrayList和linkedlist，ArrayList是数组是动态底层连续内存存储，适合随机访问，扩容机制，将老数据拷贝到新数组，使用尾插发并制定初始容量可以极大提升性能。
>
> 另一个则是链表，分散在内存中，适合插入和删除操作，不适合查询，使用iterator遍历，因为使用for循环通过get方法取得元素时需要对list重新遍历。
>
> ArrayList遍历速度快，查询快，链表增删操作快，但是在正常业务中，遍历的需求多，增加元素一般都是直接放在尾部，时间复杂度也为O（1）。



> Set集合，包含HashSet，TreeSet，LinkedHashSet，set集合用来保证数据的唯一性，其中Treeset可以排序

list 有序，按照对象进入的顺序保存对象，可以重复，可以有多个null值，可以随机access或者iterator取出所有元素。



# hashmap和hashtable区别

使用红黑树可以加快查询速度，因为在jdk1.8之后，在链表的长度大于8并且数组长度超过64后，hashmap将后面的数据存在红黑树中，（数组+链表->数组+树），时间复杂度从n到logn

内部实现是一个桶数组，每一个桶中存放一个单链表的头结点，每个结点存储的是一个键值对Entry，采用拉链法解决哈希冲突

扩容：hashmap(int initialCapacity, float factor)，第一个参数是初始容量，第二个装载因子，默认0.75，put操作时，先计算出hash值，找到对一个的桶位置，然后遍历这个桶上的链表，若没有找到与键相对的entry，新建一个。如果size已经大于阈值（factor * capacity），则扩容。

所以扩容条件是：**当`map`中包含的`Entry`的数量大于等于`threshold = loadFactor * capacity`的时候，且新建的`Entry`刚好落在一个非空的桶上，此刻触发扩容机制，将其容量扩大为2倍**。**旧桶数组中的某个桶的外挂单链表是通过尾插法插入新桶数组中的，并且原链表中的Entry结点并不一定仍然在新桶数组的同一链表**。

在多线程的情况下，很容易出现扩容无限进行链表反转的操作，容易死循环，多线程的put可能会导致元素的丢失，可能会导致get为null。

所以采用concurrentHashmap。

或者使用Collections.synchronizedMap对方法进行同步锁。

hashmap允许key和value为null，jdk1.8中是插入尾部，之前都是插入头部，并且从entry变成了node

（再哈希法，开放地址法，链地址法）hashmap采用的链地址法，哈希冲突

![image-20220722231758138](https://benchmoon-554.s3.amazonaws.com/markdownImage/image-20220722231758138.png)

因为红黑树需要左旋这些操作保持平衡，单链表不需要。当元素大于8个时，需要红黑树来加快查询速度，但是新增节点的效率变慢。如果一开始使用红黑树，那么新增慢。

加载因子0.75是对空间和时间的一个平衡选择，高了空间利用率高，但是查找成本提高。



![image-20220801105911163](/Users/linyue/Library/Application Support/typora-user-images/image-20220801105911163.png)



## hashmap扩容

jdk1.7使用的是用一个容量更大的数组来代替已有容量小的数组，将已有的entry数组元素拷贝到新的数组里，使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置，

![image-20220801110341089](https://benchmoon-554.s3.amazonaws.com/markdownImage/image-20220801110341089.png)



## ConcurrentHashMap

JDK1.7之前是由segment数组结构和hashentry数组结构组成，哈希桶分成小数组小段，每个小段有n个entry组成，期中segment继承了reentrantLock(重入锁)，entry用于存储键值对。将数据进行分段存储，每个数据都有一把锁。



jdk1.8之后改为数组+链表+红黑树结构，锁采用的是CAS+synchronized锁实现更加的低的细粒度，锁只会锁住链表的头结点，大大提高了并发度。



## ConcurrentHashMap put的执行逻辑

Jdk1.7：首先会去尝试获取锁，如果获取失败则自旋获取，自旋64次后如果还是没有获取锁则进入阻塞获取锁。

获取锁之后计算当前segment的table的key定位到hashentry，判断entry是否是空，不为空则判断进行当前的key和遍历的key相等，相等进行覆盖，不然就要新建一个hashentry加入到entry中，在这个过程中需要判断是否扩容，最后释放segment的锁



jdk1.8后，先用当前的key的hash值，判断是否需要初始化，然后定位到node，首节点为f，若f为空，则通过cas尝试添加，若f.hash=moved = -1表示其他线程正在扩容，一起加入到扩容，不然就用synchronized锁住当前节点，遍历添加。链表长度为8的时候则将链表转换为红黑树。





## ConcurrentHashMap的get方法

get方法不需要加锁，因为node的元素val和指针next都是用volatile修饰的，在多线程环境下线程A修改节点的val或者新增节点的时候是对线程B可见的。



与voliate修饰的哈希桶无关，哈希桶table用volatile修饰主要是保证数组在扩容的时候保证可见性。



## ConcurrentHashMap不支持key或者value为空

首先key不能为空是因为在设计之初，就是一直为空。value则是因为存在二义性，ConcurrentHashMap为多线程，假如A线程用get方法返回为null，我们不知道这个null是没有映射为null或者值本身就是null，那么我想验证我的猜想使用containsKey想要返回null，但是同时B线程添加了put（key，null），那么返回就是true了，会造成歧义。



ConcurrentHashMap并发度默认16，会使用2的幂次方。是弱一致性，ConcurrentHashMap迭代器创建后会按照哈希表结构遍历每个元素，但在遍历过程中元素会发生变化。如果变化发生在已经遍历完的部分，则接下来的遍历不会变动，如果放生在之后，那么迭代器就会反应出来。



## volatile怎么保证可见性和有序性的

在多线程情况下，最重要的三个问题，原子性，可见性和有序性。

可见性指的是当一个线程修改了某个共享变量的值，其他线程能够马上感知到这个修改的值。

有序性即程序执行的顺序是否按照代码的先后顺序执行。

**可见性**：在汇编层面上加lock，使用缓存一致性（MESI）解决并发可见性。lock指令让线程工作内存中的值写回主内存中，通过缓存一致性协议，如果其他线程工作内存中存了该共享变量的值，就会失效，其他线程会重新从主内存中获取最新的值。

**有序性**：通过内存屏障解决了多线程有序性问题。内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序，也就是说通过插入内存屏障禁止在内存屏障前后执行重排序优化！

```
* 在每个volatile写操作的前面插入一个StoreStore屏障。`
`* 在每个volatile写操作的后面插入一个StoreLoad屏障。`
`* 在每个volatile读操作的后面插入一个LoadLoad屏障。`
`* 在每个volatile读操作的后面插入一个LoadStore屏障。
```



## synchronized

保证可见性和有序性；通过管程保证一组动作的原子性。不保证同步块内的代码禁止重排序，因为他通过锁保证同一时刻只有一个线程访问临界区。

synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：
1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；
2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；
3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；
4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。



# hashcode 和 equals

* hashcode():   用于获取给定对象的唯一的整数（散列码），当这个对象需要存储在哈希表时，这个整数即可用来确定桶的位置。默认情况下，返回对象所在内存地址的整数表示。hash散列算法，使得hash表中查找一个记录速度为O1。在查找一个元素时，先通过hashcode快速定位记录的位置，然后通过equals来比较是否相等。
* equals():  不重新写，默认采用object 的equals（就是双等号），所以string是重写的。

hashcode的作用，如果两个对象的hashcode不同就可以不用比较值了，如果相同，在执行equals方法。





# 单点登录原理和实现sso

之前的做法是，登录之后，用户的session中标记登录状态为yes，同时在浏览器中写入cookie，这个cookie是这个用户的唯一标识。下次访问这个应用时，请求中会带上这个cookie，服务端会根据这个cookie找到对应的session，然后通过session判断这个用户是否登录。

但是cookie不能跨域，所以对多个业务系统无法无法操作，不同应用的session是存在自己的应用中，无法共享。

所以使用sso系统（在具有多个子系统的系统中，只需要登录一个子系统，其他系统则可以使用登录信息），流程如下：

1.用户首次访问A系统，A系统发现用户登录，重定向到soo认证中心并携带请求url，进行登录验证

2.用户在sso认证成功后，服务器生成一个ticket，然后重定向到A系统并带上这个ticket信息(放到url参数中)

3.系统A获取到url参数中的ticket，想sso发起ticket校验，校验成功，则A放行，并将ticket存入到cookie

4.用户访问B系统，此时B系统domain已经携带ticket，直接向sso发起校验，校验成功则继续，并将ticket存入cookie，更新过期时间

5.用户登出时，移除domain下的cookie。





# String为什么不可变

因为string的对象缓存在string池中，由于缓存的字符串存在共享情况下，如果改变了一个就会导致别的地方出现问题



# spring装载xml过程Bean

1.将程序内所有的XML或者properties加载到内存中

2.Java类解析xml了里面的内容，得到对应实体类的字节码字符串以及相关的属性信息。

3.使用反射机制，根据这个字符串获得某个类的Class实例

4，动态配置实例的属性。

好处：不用每一次都要去代码里面new；修改直接修改xml文件，方便维护；适应一些特殊需求（不能直接调用另外的方法） 



# JVM 如何处理异常

在Java中一个方法出现了异常，那么这个方法就会生成一个异常对象，该对象包含异常名称，异常描述和异常发生时应用程序的状态，然后将这个异常对象交给JVM。JVM顺着调用栈去处理，如果找到处理异常的代码，就交给这个代码去处理，把异常传递给这块代码，如果没有找到，jvm会交给异常的默认处理器。





# 字符流和字节流的区别

字节流-》字符流，通过inputsreamread 和outputStreamWrite

  1.处理单元不同

2. 字节流可以处理所有类型文件的数据传输，因为计算机的信息的最小单位就是字节，而字符流只能处理纯文本数据，其他不行，所以处理文本类型是用字符流多
3. 在读写文件需要对内容进行比对时，比如比较特定字符，处理某一行数据的时候一般选择字符流。
4. 只是读写文件，对文件内容无关时一般选用字节流。





# 阻塞IO与非阻塞IO区别

IO 操作包括对硬盘的读取， socket的读写以及外设的读写。

当用户发起一个io操作时，内核会去查看，如果数据没有准备好，就陷入等待状态，直到数据就绪。这就是阻塞。

非阻塞IO就是碰到如果这种情况，则会返回一个标志告知用户当前数据没有就绪，当数据就绪后，再将数据拷贝到用户线程，这才完成了一个IO操作。







## BIO NIO AIO

BIO：同步阻塞，在服务器中实现的模式为一个连接一个线程。有一个连接就会创造一个线程，会造成不必要的线程开销，适用于链接数目小且稳定的架构。

NIO：同步非阻塞，在服务器中实现的模式是一个请求一个线程。客户端发送的连接请求都会注册到多路复用器上，有连接IO请求才会启动一个线程处理。

AIO：异步非阻塞，在服务器中实现的模式是一个有效请求一个线程。客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。



# jvm

jvm将虚拟机分为5大区域：程序计数器，Java堆，方法区，虚拟机栈，本地方法栈

线程共享“： 堆 方法区

**2****、栈：**

又称方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法

出口等信息.调用方法时执行入栈,方法返回式执行出栈. 

**3****、本地方法栈**

与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈. 

**4****、程序计数器**

保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行

Native方法时,程序计数器为空. 

**5**堆

JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆

没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行

垃圾的回收管理

**6****、方法区：**

又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永

久代和1.8的元空间都是方法区的一种实现



## heap和stack区别

申请方式：

> stack：由系统自动分配，例如int a。但是申请得到的空间较小。
>
> heap：需要程序员自己申请，还要指明大小。获得的空间比较灵活，比较大。

申请后的响应方式:

> stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则报栈溢出的error
>
> heap：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。但是系统会将多余的那部分重新放入空闲链表。

申请效率的比较：

> stack：系统自动分配，速度较快，但是程序员无法控制
>
> heap：由new分配的内存，一般速度较快，荣易产生内存碎片，不过用起来方便。



## 什么情况会发生栈内存溢出

1.栈是线程私有的，生命周期和线程一样，每个方法在执行会创建一个栈正，包含局部变量（基本数据类型和对象的引用），操作数栈，动态链接，方法出口。当线程的请求栈深度超过了虚拟机允许的最大深度时，会抛出Stack Overflow错误。

调整参数-XSS去调整jvm栈的大小。



## jvm常量池

主要有class文件常量池，运行时常量池，全局字符串常量池，基本类型包装类对象常量池。



## JVM中一次完整的GC过程

在Java堆中，划分两个不同的区域，新生代和老生代，一个1/3一个占2/3。

新生代有三个分区Eden，To Survivorm From Survivor,默认占比8:1:1。

新生代的垃圾回收后只有少量对象存活，所以选用复制算法，只需要少了的复制成本。

老年代的垃圾回收使用 标记-》清理 或者标记-》整理算法。

大对象直接进入老年代，大对象就是需要大量连续内存空间的对象，为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率。

老年代满了，minor gc之后通常就会进行full gc，清理整个内存堆。

minor gc只收集新生代的GC，触发条件是eden区满时

full gc收集整个堆。





![image-20220801205116235](https://benchmoon-554.s3.amazonaws.com/markdownImage/2606FB4F-8E45-4441-95A9-9CDA54FB0244.png)

## 三色标记法

![image-20220801143122268](https://benchmoon-554.s3.amazonaws.com/markdownImage/image-20220801143122268.png)



## 类加载

虚拟机把描述类的数据加载到内存中，并对数据进行校验解析和初始化，最终变成可以被虚拟机直接使用的class对象。

生命周期：加载，验证，准备，解析，初始化，使用和卸载。

![image-20220722153130773](https://benchmoon-554.s3.amazonaws.com/markdownImage/image-20220722153130773.png)

类加载器是指：通过一个类的全限定性类名获取该类的二进制字节流叫做类加载器，有以下四种，

启动类加载器：用来加载Java核心类库，无法被Java程序直接引用

扩展类加载器：用来加载Java的扩展库，Java虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载Java类

系统类加载器，自定义加载器。



## 双亲委派模型

当一个类加载器收到一个类加载的请求，首先不会尝试自己加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到改类时，子加载器才会尝试自己去加载该类。

这样做为了防治内存中出现多个相同的字节码，因为没有双亲委派机制的话，用户就可以自己定义一个Java的string类，那么就无法保证类的唯一性。

如何打破： 自定义类加载器，继承classLoader类，重写loadClass和findClass方法。

打破的例子：Tomcat， JNDI，OSGI





## jvm调优的命令

jps： jvm process status tool，显示指定系统内所有的Hotspot虚拟机进程。

jstat： jvm statistics monitoring，用于监视虚拟机运行时状态信息的命令。

jmap： memory map，用于生成heap dump文件，还可以查询finalize执行队列，Java堆和永久代的详细信息。

jhat：heap，analysis tool， 与jmap搭配使用，用来分析jmap生成的dump，内置了一个微信的http服务器，生成dump的分析结果后，可以在浏览器中查看，但是比较耗性能，所以一般都复制到本地去查看。

jstack：用于生成Java虚拟机当前时刻的线程快照，查看各个线程的调用栈，就可以知道没有响应的线程到底在后台做什么，等待什么资源。



# Java并发

## 进程与线程的区别

根本区别：进程是操作系统资源分配的基本单位，线程是处理任务调度和执行基本单位。

每个进程都有独立的代码和数据空间，程序之间切换会有较大的开销。而同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，切换的开销小。

一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都会down掉，所以进程要比线程健壮。



## 创建线程的方式

1.采用实现runnalbe或者callable接口的方式创建多线程

只是实现了接口，还可以继承其他类，多个线程共享一个target对象，适用于多个相同线程来处理同一份资源的情况，从而将CPU，代码和数据分开。

但是编程稍微复杂，如果要访问当前线程，必须使用thread.currentThread方法



2.使用继承thread类的方式创建多线程

编写简单，可以直接用this获取当前线程

但是不能再继承其他父类。



Runnable和callable区别：

> 重写的方法不同，一个是run()方法，一个是call()方法。
>
> callable任务执行后可以返回值，但是run'不行
>
> call可以抛出异常，但是run不行
>
> 运行callable任务可以拿到一个future对象，表示异步计算的结果。



## 为什么使用多线程

1.线程是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小，多核CPU可以支持多个线程同时运行，减少了数据空间切换的开销。

2.互联网区域大数据，多线程并发编程正是开发高并发系统的基础，可以提高系统整体的并发能力。



## 线程状态

线程的生命周期：新建，就绪，运行，阻塞，死亡。

阻塞状态：处于运行中的线程由于某种原因，暂时放弃对CPU的使用权，直到进入就绪状态。分为是三种阻塞，

​			等待阻塞：运行状态中的线程执行wait方法，使本线程进入到等待阻塞状态

​			同步阻塞：线程在获取同步锁失败，被其他线程占用

​			其他阻塞：通过调用线程的sleep或者join或者发出了io请求



调用start方法可以启动线程并使线程进入就绪状态，而run方法只是一个thread的一个普通方法调用，还是在主线程里执行。



Thread类中的yield方法可以暂停当前正在执行的线程对象，让其他有相同优先级的线程执行。是一个静态方法，而且只保证当前线程放弃CPU占用，而不能保证使其他线程一定能占用CPU，执行yield的线程有可能在进入到暂停状态后马上又被执行。



# 线程死锁

多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放。

四个条件：互斥条件（该资源在任意一个时刻只能被一个线程使用）

​				请求与保持条件（一个进程因请求资源而阻塞时，对已经获得的资源保持不放）

​				不剥夺条件：线程已获得资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕才能释放

​				循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。



# 如何避免线程死锁

只需要破坏其中一个就行

1.无法破坏互斥条件，因为用锁的目的就是让他们互斥的

2.破坏请求与保持条件，一次性请求所有资源

3.占用部分资源的线程进一步申请资源失败后，主动释放当前资源

4.按照某一顺序申请资源。

5，锁排序法：指定获取锁的顺序，比如优先级。



## sleep 和wait区别

sleep是 thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态，睡眠时间到了后会解除阻塞，进入可运行状态，**睡眠不释放锁**。会自动苏醒进入可运行状态。

wait是object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞，**会释放互斥锁**。需要别的线程调用同一个对象上的notify方法。

sleep通常被用于暂停执行，wait通常被用于线程间的交互通信。



## 如何创建线程实例并运行

thread 类本质上是实现runnable接口的一个实例，代表了一个线程的实例。

1.创建thread的子类并重写run方法，run方法在调用start方法后被执行，而且一旦线程启动start方法后就会立即返回，而不是等到run方法执行完毕后再返回

2.实现runnable接口，在新建类时实现runnable接口，然后再thread类的构造函数中传入myrunnable的实例对象，最后执行start方法即可。



线程死亡的三种：

1. 正常结束：run或者call方法执行完成后，线程正常结束
2. 异常结束：线程抛出一个未捕获的异常或者error，导致线程结束
3. 调用stop方法，直接调用线程的stop方法来结束该线程，但是一般不推荐使用该种方式，容易导致死锁



# CAS是什么



全称是compare and swap，比较并交换，是一条cpu同步源语，是一硬件对并发的支持，针对多处理操作而设计的一种特殊指令，用于管理对共享数据的并发访问。

是一种无锁的非阻塞算法的实现。

包含了3个操作数：需要读写的内存值V，旧的预期值A，要修改的更新值B，当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作。整个过程是原子的，不会造成数据不一致问题。

## CAS缺点

1.ABA问题

2.循环时间长开销，自旋CAS一直不成功，会带来极大的开销，所以有个自旋次数

3，只能保证一个变量的原子操作，如果对多个变量，则失效，可以用互斥锁来保证原子性，将多个变量封装成对象。



## synchronized和lock有什么区别

synchronized可以给类，方法，代码块加上锁，而lock只能给代码块枷锁

sync不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁，而lock需要自己枷锁和释放锁，会造成死锁

lock可以知道有没有成功获取锁



## ThreadLocal是什么

即线程本地变量，如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到了线程隔离的作用，避免了线程安全问题，可以用在数据库连接池，会话管理中使用。



# ThreadLocal实现原理

1.thread类有一个类型为ThreadLocalmap的实例变量threadlocals，即每个线程都有一个属于自己的ThreadLocalMap.

2.ThreadLocalMap内部维护着entry数组，每个entry代表一个完整的对象，key是ThreadLocal本身，value是其泛型值。

3.每个线程再往ThreadLocal里设置value的时候，都是往自己的ThreadLocalMap里存储，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。



# 为什么要用线程池，线程池的好处

降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

提高响应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行。

提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅消耗资源，还会降低系统的稳定性，可以实现同意的分配，调优。



## 线程池的核心参数

corePoolSize：核心线程大小，线程池一直运行，核心线程就不会停止

maximumPoolSize：线程池最大的线程数量。

keepAliveTime：非核心线程的心跳时间，如果非核心线程在keepAliveTime没有运行任务，非核心线程会消亡。

workQueue：阻塞队列，用来存放线程任务

defaultHandler：饱和策略，共有4种饱和策略。

ThreadFactory：线程工程，新建线程工厂。



## 线程池执行任务的流程

![image-20220718202720472](https://benchmoon-554.s3.amazonaws.com/markdownImage/image-20220718202720472.png)



## Java常用的线程池类型

1.newCachedThreadPool



2.newFixedThreadPool



3.newSignThreadExecutor



4.newScheduleThreadPool



## 线程池阻塞队列

![image-20220718203043766](https://benchmoon-554.s3.amazonaws.com/markdownImage/image-20220718203043766.png)



## 源码中线程池是怎么复用线程的

源码中ThreadPoolExecutor中有个内置对象worker，每个worker都是一个线程，worker线程数量和参数有关，每个worker会while死循环从阻塞队列中取数据，通过置换worker中runnable对象，运行其run方法起到鲜橙汁缓的效果，从而达到线程频繁切换，提高程序性能。





# Atomic原子类

是指一个操作不可中断，一个操作一旦开始，就不会被其他线程干扰。原子类就是具有原子操作特征的类。



## JUC包中的原子类是哪4类

> 基本类型：使用原子的方式更新基本类型
>
> atomicInteger， AtomicLong， AtmoicBoolean



> 数组类型，使用原子的方式更新数组里的某个元素
>
> atomicIntegerArray, atomicLongArray, atomicReferenceArray



> 引用类型
>
> atomicReference， atomicMarkableReference



## AtomicInteger类原理

是对int类型的一个封装，提供原子性的访问和更新操作。主要利用CAS和volatile和native方法来保证原子操作，从而避免synchronized的高开销，执行效率大为提升。







# MYSQL

## MySQL索引

索引是一种特殊的文件（innodb数据表上的索引是表空间的一个组成部分），包含着对数据表里所有记录的引用指针。

索引是一种数据结构，数据库索引是管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引的实现通常使用B树及变种B+树。所以说，索引相当于一个目录，占据物理空间的。

索引可以大大提高MySQL的检索速度。



## 索引优缺点

优点：可以大大加快数据的检索速度；通过使用索引，可以在查询中使用优化影藏器，提高系统的性能。

缺点：创建索引和维护索引需要耗费时间，比如说表中的数据进行增加修改删除时，索引也要动态维护；索引需要占据物理空间



##索引底层实现

1.hash索引，基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，并且hash索引将所有的哈希吗存储在索引中，同时在索引表中保存指向每个数据行的指针。



2.B-tree该种数据结构能加快数据的访问速度，数据分布在各个节点之中。



3.B+tree是数据库索引所采用的存储结构，数据都存在叶子节点上，并且增加了顺序访问指针，每个叶子结点都指向相邻的叶子结点的地址。进行范围查找时只需要查找两个节点，进行遍历即可。关键字个数和孩子结点个数相同

b+tree性质：（非聚簇索引，二级索引）

n棵子tree的结点包含n个关键字，不用来保存数据，而是保存数据的索引。

所有叶子结点中包含了全部关键字的信息，且叶子结点本身以关键字的大小自小而大顺序连接。

B+树中，数据对象的插入和删除仅在叶结点上进行。

有两个头指针，一个树的根节点，一个是最小关键码的叶结点。



**红黑树的特性**:
**（1）每个节点或者是黑色，或者是红色。**
**（2）根节点是黑色。**
**（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
**（4）如果一个节点是红色的，则它的子节点必须是黑色的。**
**（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

![image-20220721223947261](https://benchmoon-554.s3.amazonaws.com/markdownImage/image-20220721223947261.png)



## 数据库为什么选择B+tree

1.B+树的磁盘读写代价更低，B+树的内容节点并没有指向关键字具体信息的指针，因此其内部节点相对其他树更小。

2.B+树的数据都存储在叶子结点中，分支节点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是对于B树来说，我们要找到具体的数据，需要进行一次中序遍历按顺序来扫，所以B+更合适区间查询。

3.hash虽然可以快速定位，但是没有顺序，IO复杂度高。只有memory存储引擎显示支持哈希索引，适合等值查询，不能排序，但是在查询等值时非常快，必须索引的所有列的全部内容，不支持部分索引列的匹配查找。

4.二叉树的高度不均匀，不能自平衡，IO代价高

5。红黑树，树的高度随着数据量增加而增加，io代价高。



# MySQL几种索引类型



应用层次来分：普通索引，唯一索引，复合索引。

普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。

唯一索引：索引列的值必须唯一，但允许有空值。

复合索引：多列值组成一个索引，专门用于组合搜索，效率大于索引合并。

聚簇索引：是一种数据存储方式，其实就是在同一个结构中保存了B-tree索引和数据行。





# MySQL聚簇和非聚簇索引的区别

***索引存在磁盘，因为如果断电后，重新生成索引非常耗时***

> mysql的索引类型跟存储引擎是相关的，innodb存储引擎数据文件跟索引文件全部都放在idb文件中，而myisam的数据文件放在myd文件中，所以放在myi中，所以区分两种索引，只要判断**数据跟索引是否存储在一起**



> innoodb存储引擎在进行数据插入的时候，数据必须要根索引放在一起，如果有主键就是用主键，没有主键就是用唯一键，再没有就是用6字节的rowid，因此数据绑定在一起的就是聚簇索引，而为了避免数据冗余存储，其他的索引的叶子节点中存储的都是聚簇索引的key值，因此在innodb中既有聚簇也有非聚簇，而myisam中只有非聚簇。



> 对于**非聚簇索引表**来说，表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。
>
> 
>
> 对于**聚簇索引表**来说，表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)。



# CAS是什么



全称是compare and swap，比较并交换，是一条cpu同步源语，是一硬件对并发的支持，针对多处理操作而设计的一种特殊指令，用于管理对共享数据的并发访问。

是一种无锁的非阻塞算法的实现。

包含了3个操作数：需要读写的内存值V，旧的预期值A，要修改的更新值B，当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作。整个过程是原子的，不会造成数据不一致问题。

## CAS缺点

1.ABA问题

2.循环时间长开销，自旋CAS一直不成功，会带来极大的开销，所以有个自旋次数

3，只能保证一个变量的原子操作，如果对多个变量，则失效，可以用互斥锁来保证原子性，将多个变量封装成对象。



## synchronized和lock有什么区别

synchronized可以给类，方法，代码块加上锁，而lock只能给代码块枷锁

sync不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁，而lock需要自己枷锁和释放锁，会造成死锁

lock可以知道有没有成功获取锁



## 索引下推

索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。 默认开启。

在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件。

在使用ICP的情况下，如果存在某些被索引的列作为判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。

有了索引下推优化，可以减少会标次数，只针对二级索引。



## 回表查询

InnoDB必须要有，且只有一个聚集索引。先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树。



## 覆盖索引

覆盖索引 创建一个索引，该索引包含查询中用到的所有字段，称为“覆盖索引”。 使用覆盖索引，MySQL 只需要通过索引就可以查找和返回查询所需要的数据，而不必在使用索引处理数据之后再进行回表操作。 覆盖索引可以一次性完成查询工作，有效减少IO，提高查询效率



## 自增主键作为索引

因为是B+树，自增主键是连续的，那么可以减少页分裂，而且能够减少数据的移动，每次插入都是放到最后。



## mysql执行查询过程

1.客户端通过tcp连接发送连接请求到Mysql服务器，连接器会对请求进行权限验证。

2.查缓存。（sql上任何字符的不同，都不会导致缓存命中）。

3.语法分析。

4.优化，判断是否使用索引，生成执行计划。

5.交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。



## 数据库事务

事务是一个不可分割的数据库操作序列，是数据库并发控制的基本单位，要么都执行要么都不执行。

ACID：事务中包含的操作要么都执行要么都不执行。

一致性：事务执行的结果必须是使数据库从一个一致性状态到另一个一致性状态，当数据库只包含成功事务提交的结果时，就是一个一致性状态，如果执行过程中发生故障，那么未完成事务对数据库所做的修改就使得数据库属于不一致的状态。

隔离性：一个事务不能干扰其他事务。事物之间互不干扰。

持久性：一个事务一旦提交，那么对数据库中的数据改变就是永久性的。

## 事务实现原理：

基于redo log和undo log实现。每提交一个事务必须先将该事务的所有日志写入到重做日志进行持久化，数据库通过redo log实现原子性和持久性。

每当有修改事务时，会产生undo log，如果需要回滚，则将redo log的语句反逻辑化处理，主要实现一致性。



## mysql的binlog

是记录所有数据库表结构变更以及数据修改的二进制日志。以事件形式记录，事务安全型的，主要目的是复制和恢复。三种格式：statement， row， mixed。



mysql事务隔离是通过行锁和间隙锁的组合next-key锁实现的。







## mybatis 中#{} 和 ${} 区别

* #{} 是预编译处理，而后者则是字符串替换
* mybatis在处理#{}时，会将sql中的#{} 替换为？号，调用prepareStatement的set方法来赋值
* mybatis在处理${}时，就是把${}替换成变量的值
* 使用#{} 可以有效的防止sql注入，提高系统安全性





## mysql的隔离级别有哪些

有四种隔离级别，用于限定事务内外哪些改变是可见的，哪些改变是不可见的，低级别的隔离一般支持更高的并发处理，并且拥有更低的系统开销。越往下隔离级别越高

* ***脏读***：**事务A读取到了事务B已经修改但尚未提交的数据。**
* ***不可重读*** ：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”， **事务A内部的相同查询语句在不同时刻读出的结果不一致。**
* ***幻读*** ：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。**事务A读取到了事务B提交的新增数据**。幻读跟不可重复读有点像，**不可重复读是读到数据不一样，幻读是读的数据多**了(针对的是一批数据整体，比如数据的个数)。

> read uncommitted 读取未提交内容：
>
> 在这个隔离级别，所有事务都可以看到未提交事务的执行结果，在这种级别上，可能会产生很多问题，很少用于实际应用，也被成为脏读。

> read committed 读取提交内容
>
> 大多数数据库数据库默认隔离级别，但并不是mysql默认隔离级别，一个事务开始时，只能看见已经提交事务所做的改变，一个事物从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交，支持所谓的“不可重复读”。意味着运行一个语句两次，看到的结果不同的。

> repeatable read 可重复读
>
> MySQL数据库默认隔离级别，解决了第一个隔离级别的问题，保证同一事务的多个实例在并发读取事务时，会看到同样的数据行，不过会导致另外一个问题-幻读。InnoDB和falcon存储引擎通过多版本并发控制机制解决了幻读。

> serializable 可串行化
>
> 是最高级别的隔离级。通过强制事务排序，是相互之间不能冲突，就是在每个读的数据行上枷锁。可能会导致大量的timeout和锁竞争，实际应用中很少使用到。



## 什么是MVCC

多版本并发控制，主要是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张本表同一时刻看到的数据可能是不一样的。



# MVCC解决的问题是什么

数据库并发场景有三种：

* 读读，不存在任何问题，不需要并发控制。
* 读写，有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读。
* 写写，有线程按期按问题，可能存在更新丢失问题。

> MVCC 是一种用来解决读写冲突的无锁并发控制，也就是为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联。读操作只读事务开始前的数据库快照，所以MVCC可以为数据库解决以下问题
>
> * 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
> * 解决了脏读，幻读不可重复读等事务隔离问题，但是不能解决更新丢失问题。





## MySQL复制原理：

* master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中。
* slave服务器会在一定时间间隔内对master二进制日志进行探测是否发生改变，如果发生改变，则开始一个I/O thread请求master二进制事件
* 同时主节点为每个i/o线程启动一个dump线程，用于向其发送二进制时间，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放使得数据和主节点的保持一致，最后I/Othread和sqlthread将进入睡眠状态，等待下一次被唤醒。





# Get和post区别

GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 

GET请求在URL中传送的参数是有长度限制的，而POST没有。

 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。



