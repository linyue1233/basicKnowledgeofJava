# JDK JRE JVM区别和联系

Jdk: java development kit,开发工具

Jre: java runtime environment

jvm: 虚拟机

jdk( JRE(bin,jvm,lib), Java工具)



.java 文件通过javac编译城.class文件，最后通过jvm映射到系统调用。



# == 和equals区别

一个是运算符一个是方法， equals不能用于基本数据类型

== 如果比较的对象是基本数据类型，比较数值是否相等，如果是引用数据类型，则是堆中的对象的地址值是否相等

equals 用来比较两个对象的内容是否相等。





# 堆栈区别

线程独享：栈，程序计数器

线程共享： 堆， 方法区

栈：又称方法栈，用来存储局部变量，操作栈，方法出口等。

堆：JVM内存管理中最大的一块，存放的是对象的实例，如果堆中没有空间，就会爆出OOM，根据对象的存活周期不同，jvm的把对象进行分代管理，由垃圾回收器回收。





#  Java的接口和抽象类有哪些去区别

**相同**：

> 不能实例化， 可以将抽象类和接口类型作为引用类型
>
> 一个类如果继承了某个抽象类或者实现某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明抽象类。

**区别**：

> ​		抽象类：
>
> *  ***抽象类中可以定义构造器***
> *  ***可以有抽象方法和具体方法***
> *  抽象类中的成员可以是privat，protected或者public
> *  抽象类中可以定义成员变量
> *  ***有抽象方法的类必须被声明为抽象类，有抽象类的未必要有抽象方法***
> *  ***抽象类中可以包含静态方法***
> *  ***一个类只能继承一个抽象类***



> 接口：
>
> * 接口中不能定义构造器
> * 方法全部都是抽象方法
> * 接口中的成员全部都是public
> * 接口中不能有静态方法
> * 一个类可以实现多个接口



抽象类重点是描述的一个抽象概念，比如说一个动物，哺乳动物。

接口描述某些事物具有的共同特征，比如说飞，鸟和飞机。

中高级回答：

接口的设计目的是对类的行为进行约束

抽象类主要是代码复用。 



# Java面向对象特征

* 继承：从已有的类中派生出新的类，新的类吸收已有类的数据属性和方法，并继承新的能力。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性和方法。通过extends关键字来实现继承，父类中通过private定义的变量和方法不会被继承，但是可以操作。
* 封装：隐藏了类的内部实现机制，同时保护了数据，对外界它的内部细节是隐藏的，不必关心方法的内部实现，
* 多态：指的是类和类之间的关系（重载，重写），必备的三个要素，继承，重写，父类引用指向子类对象。基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。可移植性，健壮性。



# fina 作用，为什么局部内部类和匿名内部类只能访问局部final变量

修饰类：类不可以被继承

方法：表示不可被子类覆盖，但是可以重载

修饰变量：一旦被赋值就不能更改。



final修饰的类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值

修饰成员变量：可以在非静态初始化块，声明改该变量或者构造器中执行赋值。



修饰局部变量：

系统不会为局部变量进行初始化，局部变量必须有程序员显示初始化。因此使用final修饰局部变量是，即可以在定义时指定默认值，后面就不能对变量再赋值。或者不指定默认值，后续代码块变量赋值（用一次）。



修饰基本类型数据：则其数值一旦在初始化之后不能再次更改

修饰引用类型数据，声明之后不能再指向别的对象，但是引用的值是可以变的。



为什么内部类只能访问局部final，因为会生成两个,class文件，内部类不会随着外部类执行完成就会被销毁（比如说线程），所以外部类方法结束后，局部变量会被销毁，但是内部类有可能还会使用者局部变量。为了解决这个问题，jvm复制了一份作为内部类的成员变量。但是要保证两个变量是一样的，所以就将该局部变量设置为final。





## 重载重写的区别

* 重写：实现的是运行是的多态性，重写发生在子类与父类中，重写方法要求子类与父类有相同的返回类型。参数列表必须与被重写方法一直，构造方法不能被重写，final，static声明的方法都不能被重写，不能抛出新的强制性异常。访问权限不能比父类中被重写的方法的访问权限更低，private父类则子类不能重写该方法。
* 重载：实现的编译时的多态性，发生在一个类中，同名的方法如果有不同的参数列表则视为重载，没有返回类型的特殊要求。可以存在于父类和子类中，可以抛出不同的异常，可以有不同修饰符。

 

# StringBuilder， StringBuffer

* String: 引用的字符串内容不能被改变，每次操作都会生成一个新的string对象。
* StringBuffer: 字符串类型可以直接修改，jdk1.0，线程安全。
* StringBuilder: 字符串类型可以直接修改，jdk1.5与sb的区别他是在单线程环境下使用的，所有的方法都没有被synchronized，底层是数组，value表示数组的值，count表示被占用的长度，会做扩容，因此效率理论上更高。





# List 和set

> List集合，包含ArrayList和linkedlist，ArrayList是数组是动态底层连续内存存储，适合随机访问，扩容机制，将老数据拷贝到新数组，使用尾插发并制定初始容量可以极大提升性能。
>
> 另一个则是链表，分散在内存中，适合插入和删除操作，不适合查询，使用iterator遍历，因为使用for循环通过get方法取得元素时需要对list重新遍历。
>
> ArrayList遍历速度快，查询快，链表增删操作快，但是在正常业务中，遍历的需求多，增加元素一般都是直接放在尾部，时间复杂度也为O（1）。



> Set集合，包含HashSet，TreeSet，LinkedHashSet，set集合用来保证数据的唯一性，其中Treeset可以排序

list 有序，按照对象进入的顺序保存对象，可以重复，可以有多个null值，可以随机access或者iterator取出所有元素。



# hashmap和hashtable区别

使用红黑树可以加快查询速度，因为在jdk1.8之后，在链表的长度大于8后，hashmap将后面的数据存在红黑树中，（数组+链表->数组+树），时间复杂度从n到logn

内部实现是一个桶数组，每一个桶中存放一个单链表的头结点，每个结点存储的是一个键值对Entry，采用拉链法解决哈希冲突

扩容：hashmap(int initialCapacity, float factor)，第一个参数是初始容量，第二个装载因子，默认0.75，put操作时，先计算出hash值，找到对一个的桶位置，然后遍历这个桶上的链表，若没有找到与键相对的entry，新建一个。如果size已经大于阈值（factor * capacity），则扩容。

所以扩容条件是：**当`map`中包含的`Entry`的数量大于等于`threshold = loadFactor * capacity`的时候，且新建的`Entry`刚好落在一个非空的桶上，此刻触发扩容机制，将其容量扩大为2倍**。**旧桶数组中的某个桶的外挂单链表是通过头插法插入新桶数组中的，并且原链表中的Entry结点并不一定仍然在新桶数组的同一链表**。

在多线程的情况下，很容易出现无限进行链表反转的操作，容易死循环，所以采用concurrentHashmap。

或者使用Collections.synchronizedMap对方法进行同步锁。

hashmap允许key和value为null，jdk1.8中是插入尾部，之前都是插入头部，并且从entry变成了node



# hashcode 和 equals

* hashcode():   用于获取给定对象的唯一的整数（散列码），当这个对象需要存储在哈希表时，这个整数即可用来确定桶的位置。默认情况下，返回对象所在内存地址的整数表示。hash散列算法，使得hash表中查找一个记录速度为O1。在查找一个元素时，先通过hashcode快速定位记录的位置，然后通过equals来比较是否相等。
* equals():  不重新写，默认采用object 的equals（就是双等号），所以string是重写的。

hashcode的作用，如果两个对象的hashcode不同就可以不用比较值了，如果相同，在执行equals方法。





# 单点登录原理和实现sso

之前的做法是，登录之后，用户的session中标记登录状态为yes，同时在浏览器中写入cookie，这个cookie是这个用户的唯一标识。下次访问这个应用时，请求中会带上这个cookie，服务端会根据这个cookie找到对应的session，然后通过session判断这个用户是否登录。

但是cookie不能跨域，所以对多个业务系统无法无法操作，不同应用的session是存在自己的应用中，无法共享。

所以使用sso系统（在具有多个子系统的系统中，只需要登录一个子系统，其他系统则可以使用登录信息），流程如下：

1.用户首次访问A系统，A系统发现用户登录，重定向到soo认证中心并携带请求url，进行登录验证

2.用户在sso认证成功后，服务器生成一个ticket，然后重定向到A系统并带上这个ticket信息(放到url参数中)

3.系统A获取到url参数中的ticket，想sso发起ticket校验，校验成功，则A方形，并将ticket存入到cookie

4.用户访问B系统，此时B系统domain已经携带ticket，直接向sso放弃校验，校验成功则继续，并将ticket存入cookie，更新过期时间

5.用户登出时，移除domain下的cookie。





# String为什么不可变

因为string的对象缓存在string池中，由于缓存的字符串存在共享情况下，如果改变了一个就会导致别的地方出现问题





# JVM 如何处理异常

在Java中一个方法出现了异常，那么这个方法就会生成一个异常对象，该对象包含异常名称，异常描述和异常发生时应用程序的状态，然后将这个异常对象交给JVM。JVM顺着调用栈去处理，如果找到处理异常的代码，就交给这个代码去处理，把异常传递给这块代码，如果没有找到，jvm会交给异常的默认处理器。





# 字符流和字节流的区别

字节流-》字符流，通过inputsreamread 和outputStreamWrite

  1.处理单元不同

2. 字节流可以处理所有类型文件的数据传输，因为计算机的信息的最小单位就是字节，而字符流只能处理纯文本数据，其他不行，所以处理文本类型是用字符流多
3. 在读写文件需要对内容进行比对时，比如比较特定字符，处理某一行数据的时候一般选择字符流。
4. 只是读写文件，对文件内容无关时一般选用字节流。





# 阻塞IO与非阻塞IO区别

IO 操作包括对硬盘的读取， socket的读写以及外设的读写。

当用户发起一个io操作时，内核会去查看，如果数据没有准备好，就陷入等待状态，直到数据就绪。这就是阻塞。

非阻塞IO就是碰到如果这种情况，则会返回一个标志告知用户当前数据没有就绪，当数据就绪后，再将数据拷贝到用户线程，这才完成了一个IO操作。



# jvm

jvm将虚拟机分为5大区域：程序计数器，Java堆，方法区，虚拟机栈，本地方法栈

线程共享“： 堆 方法区

**2****、栈：**

又称方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法

出口等信息.调用方法时执行入栈,方法返回式执行出栈. 

**3****、本地方法栈**

与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈. 

**4****、程序计数器**

保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行

Native方法时,程序计数器为空. 

**5**堆

JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆

没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行

垃圾的回收管理

**6****、方法区：**

又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永

久代和1.8的元空间都是方法区的一种实现



## heap和stack区别

申请方式：

> stack：由系统自动分配，例如int a。但是申请得到的空间较小。
>
> heap：需要程序员自己申请，还要指明大小。获得的空间比较灵活，比较大。

申请后的响应方式:

> stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则报栈溢出的error
>
> heap：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。但是系统会将多余的那部分重新放入空闲链表。

申请效率的比较：

> stack：系统自动分配，速度较快，但是程序员无法控制
>
> heap：由new分配的内存，一般速度较快，荣易产生内存碎片，不过用起来方便。



## 什么情况会发生栈内存溢出

1.栈是线程私有的，生命周期和线程一样，每个方法在执行会创建一个栈正，包含局部变量（基本数据类型和对象的引用），操作数栈，动态链接，方法出口。当线程的请求栈深度超过了虚拟机允许的最大深度时，会抛出Stack Overflow错误。

调整参数-XSS去调整jvm栈的大小。



## jvm常量池

主要有class文件常量池，运行时常量池，全局字符串常量池，基本类型包装类对象常量池。



## JVM中一次完整的GC过程

在Java堆中，划分两个不同的区域，新生代和老生代，一个1/3一个占2/3。

新生代有三个分区Eden，To Survivorm From Survivor,默认占比8:1:1。

新生代的垃圾回收后只有少量对象存活，所以选用复制算法，只需要少了的复制成本。

老年代的垃圾回收使用 标记-》清理 或者标记-》整理算法。

大对象直接进入老年代，大对象就是需要大量连续内存空间的对象，为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率。

老年代满了，minor gc之后通常就会进行full gc，清理整个内存堆。

minor gc只收集新生代的GC，触发条件是eden区满时

full gc收集整个堆。



## 类加载

虚拟机把描述类的数据加载到内存中，并对数据进行校验解析和初始化，最终变成可以被虚拟机直接使用的class对象。

生命周期：加载，验证，准备，解析，初始化，使用和卸载。

类加载器是指：通过一个类的全限定性类名获取该类的二进制字节流叫做类加载器，有以下四种，

启动类加载器：用来加载Java核心类库，无法被Java程序直接引用

扩展类加载器：用来加载Java的扩展库，Java虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载Java类

系统类加载器，自定义加载器。



## 双亲委派模型

当一个类加载器收到一个类加载的请求，首先不会尝试自己加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到改类时，子加载器才会尝试自己去加载该类。

这样做为了防治内存中出现多个相同的字节码，因为没有双亲委派机制的话，用户就可以自己定义一个Java的string类，那么就无法保证类的唯一性。

如何打破： 自定义类加载器，继承classLoader类，重写loadClass和findClass方法。

打破的例子：Tomcat， JNDI，OSGI





## jvm调优的命令

jps： jvm process status tool，显示指定系统内所有的Hotspot虚拟机进程。

jstat： jvm statistics monitoring，用于监视虚拟机运行时状态信息的命令。

jmap： memory map，用于生成heap dump文件，还可以查询finalize执行队列，Java堆和永久代的详细信息。

jhat：heap，analysis tool， 与jmap搭配使用，用来分析jmap生成的dump，内置了一个微信的http服务器，生成dump的分析结果后，可以在浏览器中查看，但是比较耗性能，所以一般都复制到本地去查看。

jstack：用于生成Java虚拟机当前时刻的线程快照，查看各个线程的调用栈，就可以知道没有响应的线程到底在后台做什么，等待什么资源。



# Java并发

## 进程与线程的区别

根本区别：进程是操作系统资源分配的基本单位，线程是处理任务调度和执行基本单位。

每个进程都有独立的代码和数据空间，程序之间切换会有较大的开销。而同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，切换的开销小。

一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都会down掉，所以进程要比线程健壮。



## 创建线程的方式

1.采用实现runnalbe或者callable接口的方式创建多线程

只是实现了接口，还可以继承其他类，多个线程共享一个target对象，适用于多个相同线程来处理同一份资源的情况，从而将CPU，代码和数据分开。

但是编程稍微复杂，如果要访问当前线程，必须使用thread.currentThread方法



2.使用继承thread类的方式创建多线程

编写简单，可以直接用this获取当前线程

但是不能再继承其他父类。



Runnable和callable区别：

> 重写的方法不同，一个是run()方法，一个是call()方法。
>
> callable任务执行后可以返回值，但是run'不行
>
> call可以抛出异常，但是run不行
>
> 运行callable任务可以拿到一个future对象，表示异步计算的结果。



## 为什么使用多线程

1.线程是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小，多核CPU可以支持多个线程同时运行，减少了数据空间切换的开销。

2.互联网区域大数据，多线程并发编程正是开发高并发系统的基础，可以提高系统整体的并发能力。



## 线程状态

线程的生命周期：新建，就绪，运行，阻塞，死亡。

阻塞状态：处于运行中的线程由于某种原因，暂时放弃对CPU的使用权，直到进入就绪状态。分为是三种阻塞，

​			等待阻塞：运行状态中的线程执行wait方法，使本线程进入到等待阻塞状态

​			同步阻塞：线程在获取同步锁失败，被其他线程占用

​			其他阻塞：通过调用线程的sleep或者join或者发出了io请求



调用start方法可以启动线程并使线程进入就绪状态，而run方法只是一个thread的一个普通方法调用，还是在主线程里执行。



Thread类中的yield方法可以暂停当前正在执行的线程对象，让其他有相同优先级的线程执行。是一个静态方法，而且只保证当前线程放弃CPU占用，而不能保证使其他线程一定能占用CPU，执行yield的线程有可能在进入到暂停状态后马上又被执行。



# 线程死锁

多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放。

四个条件：互斥条件（该资源在任意一个时刻只能被一个线程使用）

​				请求与保持条件（一个进程因请求资源而阻塞时，对已经获得的资源保持不放）

​				不剥夺条件：线程已获得资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕才能释放

​				循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。



# 如何避免线程死锁

只需要破坏其中一个就行

1.无法破坏互斥条件，因为用锁的目的就是让他们互斥的

2.破坏请求与保持条件，一次性请求所有资源

3.占用部分资源的线程进一步申请资源失败后，主动释放当前资源

4.按照某一顺序申请资源。

5，锁排序法：指定获取锁的顺序，比如优先级。



## sleep 和wait区别

sleep是 thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态，睡眠时间到了后会解除阻塞，进入可运行状态，**睡眠不释放锁**。会自动苏醒进入可运行状态。

wait是object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞，**会释放互斥锁**。需要别的线程调用同一个对象上的notify方法。

sleep通常被用于暂停执行，wait通常被用于线程间的交互通信。



## 如何创建线程实例并运行

thread 类本质上是实现runnable接口的一个实例，代表了一个线程的实例。

1.创建thread的子类并重写run方法，run方法在调用start方法后被执行，而且一旦线程启动start方法后就会立即返回，而不是等到run方法执行完毕后再返回

2.实现runnable接口，在新建类时实现runnable接口，然后再thread类的构造函数中传入myrunnable的实例对象，最后执行start方法即可。



线程死亡的三种：

1. 正常结束：run或者call方法执行完成后，线程正常结束
2. 异常结束：线程抛出一个未捕获的异常或者error，导致线程结束
3. 调用stop方法，直接调用线程的stop方法来结束该线程，但是一般不推荐使用该种方式，容易导致死锁



# CAS是什么



全称是compare and swap，比较并交换，是一条cpu同步源语，是一硬件对并发的支持，针对多处理操作而设计的一种特殊指令，用于管理对共享数据的并发访问。

是一种无锁的非阻塞算法的实现。

包含了3个操作数：需要读写的内存值V，旧的预期值A，要修改的更新值B，当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作。整个过程是原子的，不会造成数据不一致问题。

## CAS缺点

1.ABA问题

2.循环时间长开销，自旋CAS一直不成功，会带来极大的开销，所以有个自旋次数

3，只能保证一个变量的原子操作，如果对多个变量，则失效，可以用互斥锁来保证原子性，将多个变量封装成对象、



## synchronized和lock有什么区别

synchronized可以给类，方法，代码块加上锁，而lock只能给代码块枷锁

sync不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁，而lock需要自己枷锁和释放锁，会造成死锁

lock可以知道有没有成功获取锁



## ThreadLocal是什么

即线程本地变量，如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到了线程隔离的作用，避免了线程安全问题，可以用在数据库连接池，会话管理中使用。



# ThreadLocal实现原理

1.thread类有一个类型为ThreadLocalmap的实例变量threadlocals，即每个线程都有一个属于自己的ThreadLocalMap.

2.ThreadLocalMap内部维护着entry数组，每个entry代表一个完整的对象，key是ThreadLocal本身，value是其泛型值。

3.每个线程再往ThreadLocal里设置value的时候，都是往自己的ThreadLocalMap里存储，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。



# 为什么要用线程池，线程池的好处

降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

提高响应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行。

提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅消耗资源，还会降低系统的稳定性，可以实现同意的分配，调优。



## 线程池的核心参数

corePoolSize：核心线程大小，线程池一直运行，核心线程就不会停止

maximumPoolSize：线程池最大的线程数量。

keepAliveTime：非核心线程的心跳时间，如果非核心线程在keepAliveTime没有运行任务，非核心线程会消亡。

workQueue：阻塞队列，用来存放线程任务

defaultHandler：饱和策略，共有4种饱和策略。

ThreadFactory：线程工程，新建线程工厂。



## 线程池执行任务的流程

![image-20220718202720472](/Users/linyue/Library/Application Support/typora-user-images/image-20220718202720472.png)



## Java常用的线程池类型

1.newCachedThreadPool



2.newFixedThreadPool



3.newSignThreadExecutor



4.newScheduleThreadPool



## 线程池阻塞队列

![https://benchmoon-554.s3.amazonaws.com/markdownImage/image-20220718203043766.png)







# BIO NIO AIO

