# 描述一下Object类中常用的方法

* toString() : 定义一个对象的字符串表现形成，可以重写，没有重写即是类的全路径名+@+对象的哈希码值
* hashcode():   用于获取给定对象的唯一的整数（散列码），当这个对象需要存储在哈希表时，这个整数即可用来确定桶的位置。默认情况下，返回对象所在内存地址的整数表示。hash散列算法，使得hash表中查找一个记录速度为O1。在查找一个元素时，先通过hashcode快速定位记录的位置，然后通过equals来比较是否相等。
* equals():  
* Clone(): 深拷贝，浅拷贝，使用这个效率高
* finalized: GC时会调动该方法，自救。

> 浅拷贝就是重新创建一个对象，这个新对象有被拷贝的属性值，如果被拷贝的对象是基本类型，拷贝就是基本类型的值，如果是引用类型，则是内存地址，一荣俱荣的那种关系。
>
> ![image-20220115224736264](/Users/linyue/Library/Application Support/typora-user-images/image-20220115224736264.png)
>
> 深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存，当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。
>
> ![image-20220115224747810](/Users/linyue/Library/Application Support/typora-user-images/image-20220115224747810.png)



## JDK1.8特性

* lambda表达式，匿名内部类
* 函数式接口，函数式编程
* 方法引用和和构造器调用
* stream Api
* 新的日期API



## == 和equals的qubie

> 一个是运算符一个是方法， equals不能用于基本数据类型
>
> == 如果比较的对象是基本数据类型，比较数值是否相等，如果是引用数据类型，则是对象的地址值是否相等
>
> equals 用来比较两个对象的内容是否相等





## Java中异常处理机制

通过五个关键字： throw， try，catch，finally，throws

throw和throws区别：

> throw：方法内部，比如说抛出一个异常在catch块，后面加具体的异常对象，相当于异常的制造者。
>
> throws：在方法的签名处，有可能会有异常。后面加异常类型，表明这个方法有可能存在异常，需要处理。





## 重载重写的区别

* 重写：实现的是运行是的多态性，重写发生在子类与父类中，重写方法要求子类与父类有相同的返回类型。参数列表必须与被重写方法一直，构造方法不能被重写，final，static声明的方法都不能被重写，不能抛出新的强制性异常。访问权限不能比父类中被重写的方法的访问权限更低。
* 重载：实现的编译时的多态性，发生在一个类中，同名的方法如果有不同的参数列表则视为重载，没有返回类型的特殊要求。可以存在于父类和子类中，可以抛出不同的异常，可以有不同修饰符。





## String, StringBuffer, StringBuilder区别和使用场景

* String: 引用的字符串内容不能被改变，
* StringBuffer: 字符串类型可以直接修改，jdk1.0，线程安全。
* StringBuilder: 字符串类型可以直接修改，jdk1.5与sb的区别他是在单线程环境下使用的，所有的方法都没有被synchronized，底层是数组，value表示数组的值，count表示被占用的长度，会做扩容，因此效率理论上更高。



## 怎样声明一个类不会被继承，什么场景会用

如果一个类被final修饰，此类不可以有子类，不能被继承，不能被重写，通常Math类，生成随机数，PI。



